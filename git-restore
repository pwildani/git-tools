#!/usr/bin/env python

import argparse
import re
import subprocess
import sys

COMMIT_TEMPLATE = \
"""
Restore "{original_commit_subject}"

This restores commit {original_commit_id}

{related_commits}
{new_body}
"""

REVERT_RX = re.compile('(?:This reverts commit|This restores commit) (.*).')

# This is also the signature separator in mime text-plain content (i.e. email).
# It's used here so that emailing these commits around doesn't mess up the
# formatting.
MULTI_BODY_MARKER = "-- "


def commit_description(commit_id):
  """Returns: (subject, body)"""
  raw = check_output([
    'git', 'show', '-s', '--format=format:%B', str(commit_id)])
  lines = raw.strip().split('\n')
  body_start = 1
  if len(lines) > 2 and not lines[1]:
    body_start = 2
  return lines[0], '\n'.join(lines[body_start:])


def commit_rev_topo_order(commit_ids):
  """ 'newest' commit first """
  raw = check_output(['git', 'rev-list'] + commit_ids)
  lines = raw.strip().split('\n')
  return [l for l in lines if l in commit_ids]

def run(commandline):
  print commandline
  return subprocess.check_call(commandline)

def check_output(commandline):
  print commandline
  return subprocess.check_output(commandline)

def commits_after(commit_id):
  raw = subprocess.check_output([
    'git', 'log', '--format=format:%H',
    commit_id + '..'])
  return [r for r in raw.strip().split('\n') if r]


parser = argparse.ArgumentParser()
parser.add_argument(
  "--rewrite-revert-to-restore-in-place",
  action="store_true",
  dest="inplace",
  default=False, help="Apply the restore template to an already-existing commit created by git-revert")
parser.add_argument("commits", help="hash of commits to restore", nargs="*")
args = parser.parse_args()


history = check_output(['git', 'rev-list', 'HEAD']).split('\n')
for commit in args.commits:
  if commit not in history:
    print 'commit %s is not an ancestor of HEAD. It is unsafe to do a restore.' % commit
    sys.exit(1)

for commit in commit_rev_topo_order(args.commits):
  if args.inplace:
    revert = commit

  else:
    print 'not in place is not implemented yet, git revert the revert to undo then use --rewrite-revert-to-restore-in-place'
    # TODO: execute a git revert on a revert then mutate that commit into a restore.
    revert = None
    sys.exit(1)

  # We have a git-revert created commit. Transform it into a restore.

  # Find the original commit for the revert, including going back through
  # chains of revert-restore-revert...
  rtarget = revert
  target = None
  is_original = False
  extras = []
  related = set()
  while not is_original:
    print 'Examining revert', rtarget
    is_original = True
    subject, body = commit_description(rtarget)

    # Examine the body for evidence of git-revert or this script being run on
    # it.
    lines = iter(body.split('\n'))
    for line in lines:
      m = REVERT_RX.match(body)
      if m:
        rtarget = m.group(1)
        is_original = False
        related.add(rtarget)
      else:
        m = re.match('Related commit: (.*)')
        if m:
          related.add(m.group(1))
        elif line:
          # After the extra cruft revert and restore add at the start.
          # Accumulate description blocks from the rest of the lines here.
          extras.extend('\n'.join(lines).split(MULTI_BODY_MARKER))
          # lines is alerady consumed, so the loop should end here anyway
          break

    if not is_original:
      target = rtarget
  if not target:
    print 'Commit %s is not a revert' % revert
    sys.exit(1)

  tsubject, tbody = commit_description(target)

  related = '\n'.join('Related commit: ' + r for r in sorted(related))
  extras[0:0] = [tbody.strip()]
  extras = [e.strip() for e in extras]

  # deduplicate previous change body descriptions without changing the order.
  blocks = set(extras)
  newbody = []
  for e in extras:
    if e in blocks and e:
      newbody.append(e)
      blocks.remove(e)

  newbody = ('\n\n%s\n\n'%(MULTI_BODY_MARKER)).join(newbody)

  new_desc = COMMIT_TEMPLATE.format(
    original_commit_subject=tsubject,
    original_commit_id=target,
    related_commits=related + ('\n' if related else ''),
    new_body=newbody,
  )

  # This is basically a rebase with a reword on the target commit, but that's
  # not trivially expressible as a script.
  to_restore = commits_after(revert)
  print 'to_restore', to_restore
  run(['git', 'reset', '--hard', revert])
  run(['git', 'commit', '--amend', '-m', new_desc])
  if to_restore:
    run(['git', 'cherry-pick'] + list(reversed(to_restore)))
